<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="{{url_for('static', filename='css/whiteboard-style.css')}}" type="text/css">

    <!-- MathQuill, used for entering math expressions -->
    <link rel="stylesheet" href="{{ url_for('static', filename = 'mathquill-0.10.1/mathquill-basic.css') }}" />
    <script src="{{ url_for('static', filename = 'jquery/jquery-3.7.0.js') }}"></script>
    <script src="{{ url_for('static', filename = 'mathquill-0.10.1/mathquill.js') }}"></script>
    <script>
      var MQ = MathQuill.getInterface(2)
    </script>

    <!-- jsplumb community edition, used to make the nodes -->
    <link rel="stylesheet" href="{{ url_for('static', filename = 'node_modules/@jsplumb/browser-ui/css/jsplumbtoolkit-demo.css') }}" type="text/css" />
    <script src="{{ url_for('static', filename = 'node_modules/@jsplumb/browser-ui/js/jsplumb.browser-ui.umd.js') }}"></script>

    <!-- tex-math-parser, self-explanatory -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/tex-math-parser@2.0.4/dist/index.js"></script>

    <!-- KaTeX, used for rendering math expressions -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous" />
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>

    <!-- Highlight.js, used for syntax-highlighting the generated code -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/matlab.min.js"></script>

  </head>
  <body>
    <h1>Kieran's Whiteboard</h1>
    <!-- <button onclick="createInputEq()">Create Input Equation Node</button> -->
    <div id="whiteboard" class="whiteboard">
    </div>
    <script>
      var parser = import("https://cdn.jsdelivr.net/npm/tex-math-parser@2.0.4/dist/index.js");
      element2 = document.getElementById('element2');
      
      jsPlumb.ready(() => {
        var MQ = MathQuill.getInterface(2)
      
        const instance = jsPlumb.newInstance({
            container: whiteboard,
            connector: {
                type: jsPlumb.BezierConnector.type,
                options: {
                curviness: 25
                }
            }
        })
      
        whiteboard = document.getElementById('whiteboard')
      
        class input_eq_node {
          update() {
            let x = this;
            x.tex = x.mathField.latex();
            x.parsed_expr_tree = parser.parseTex(x.tex);
            console.log(x.parsed_expr_tree);
            let parsed_free_symbols =['sigma']
            let parsed_free_symbols_tex = ['\\sigma']
            //loop through all the symbols in the current equation and see if they're still there, remove them otherwise
            for (let i = 0; i < x.symbols_srepr.length; i++) {
              if (!parsed_free_symbols.includes(x.symbols_srepr[i])) {
                x.symbols_srepr.splice(i, 1)
                x.symbols_tex.splice(i, 1)
                console.log(x.symbols_tex)
                x.symbol_cells[i].remove()
                x.symbol_cells.splice(i, 1)
                instance.deleteEndpoint(x.endpoints[i])
                x.endpoints.splice(i, 1)
                i--
              }
            }
      
            //loop through all the symbols returned from the parser and see if they're already here, add them otherwise
            for (let i = 0; i < parsed_free_symbols.length; i++) {
              if (!x.symbols_srepr.includes(parsed_free_symbols[i])) {
                x.symbols_srepr.push(parsed_free_symbols[i])
                x.symbols_tex.push(parsed_free_symbols_tex[i])
                x.symbol_cells.push(document.createElement('th'))
                x.symbol_cells[x.symbol_cells.length - 1].classList.add('symbolLabel')
                katex.render(parsed_free_symbols_tex[i], x.symbol_cells[x.symbol_cells.length - 1], {
                  throwOnError: false
                })
                x.symbolAnchorContainer.appendChild(x.symbol_cells[x.symbol_cells.length - 1])
                x.endpoints.push(
                  instance.addEndpoint(x.container, {
                    source: true,
                    endpoint: 'Rectangle',
                    anchor: 'Bottom'
                  })
                )
              }
            }
      
            //move all anchors to where their respective symbols are to account for added or removed symbols
            for (let i = 0; i < x.symbols_srepr.length; i++) {
              x.endpoints[i].setAnchor([0, 1, 0, 1, x.symbol_cells[i].getBoundingClientRect().width / 2 + x.symbol_cells[i].offsetLeft + x.symbolAnchorContainerTable.offsetLeft + x.symbolAnchorContainer.offsetLeft, 0])
            }
      
            //code that goes in all nodes to allow recursive updating of everything downstream
            for (let i = 0; i < this.children.length; i++) {
              this.children[i].update()
            }
          }
          constructor(default_tex = '') {
            let x = this
            this.tex = default_tex
            this.srepr = ''
            this.symbols_tex = []
            this.symbols_srepr = []
            this.symbol_cells = []
            this.endpoints = []
            this.children = []
      
            this.container = document.createElement('span')
            this.container.classList.add('draggableNode')
            whiteboard.appendChild(this.container)
            this.mathFieldSpan = document.createElement('span')
            this.container.appendChild(this.mathFieldSpan)
            this.symbolAnchorContainerTable = document.createElement('table')
            this.symbolAnchorContainerTable.classList.add('symbolAnchorContainerTable')
            this.container.appendChild(this.symbolAnchorContainerTable)
            this.symbolAnchorContainer = document.createElement('tr')
            this.symbolAnchorContainerTable.appendChild(this.symbolAnchorContainer)
      
            this.mathFieldSpan.innerHTML = default_tex
      
            this.mathField = MQ.MathField(this.mathFieldSpan, {
              spaceBehavesLikeTab: true, // configurable
              handlers: {
                edit: function () {
                  autoCommands: 'pi sqrt', x.update()
                }
              }
            })
            instance.manage(this.container)
            this.update()
          }
        }
        inputEqNodes = []
        inputEqNodes.push(new input_eq_node('ax^2+bx+c=0'))
        inputEqNodes.push(new input_eq_node('\\sigma=\\frac{P}{A}'))
      
        function createInputEq() {
          inputEqNodes.push(new input_eq_node())
        }
        //stdEqNode = new std_eq_node((parent = null), (srepr = "Equality(Symbol('v'), Pow(Mul(Symbol('mu'), Add(Mul(Integer(2), Pow(Symbol('r'), Integer(-1))), Mul(Integer(-1), Pow(Symbol('a'), Integer(-1))))), Rational(1, 2)))"), (tex = 'v = \\sqrt{\\mu \\left(\\frac{2}{r} - \\frac{1}{a}\\right)}'))
        createInputEq()
      })
    </script>
  </body>
</html>
